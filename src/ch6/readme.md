# CH6  기본적인 리팩토링

이 장에서는 가장 기본적이면서 많이 사용해서 제일 먼저 배워야하는 리팩토링으로 시작한다.

#### 저수준 리팩터링 
- item1 함수 추출하기(6.1)
- 변수 추출하기(6.3)
- 함수 인라인하기(6.2) != (6.1)
- item3 변수 인라인하기(6.4) != (6.3)
- item5 함수 선언바꾸기(6.5)
- 변수 이름바꾸기(6.7)
- item6 변수 캡슐화하기(6.6) ~ (6.7)
- item8 매개변수 객체 만들기(6.8)

#### 고수준 리팩터링
- item9 여러 함수를 클래스로 묶기(6.9)
- item10 여러 함수를 변환함수로 묶기(6.10)
- item11 단계 쪼개기(6.11)

----

## 함수 추출하기
- 코드의 목적(강조)과 구현(반전)을 분리한다.
- '어떻게'가 아닌 '무엇을' 하는지가 드러나야한다.
- 팁(Tip)
    - 함수의 길이는 중요하지 않다.
        - 단 한줄짜리 함수를 만들어도 상관없다.
    - 성능 최적화는 지침에 따라라(하지마라)
    - 추출한 함수의 이름을 지을때 주석을 참고하면 도움이 된다.
    - *본문 코드가 이름만큼 깔끔하다면, 함수를 추출하지 않아도 된다.*

## 변수 추출하기
- 표현식이 너무 복잡해서 이해하기 어려울때 사용한다.
- 팁(tip)
    - 함수를 벗어난 넓은 문맥에서까지 사용된다면 함수로 뽑아라

## 매개변수 객체 만들기
- 데이터 무리를 발견하면 데이터 구조를 하나로 모아주자.
- 장점
    - 데이터 사이의 광계가 명확해진다.
    - 매개변수 수가 줄어든다.
    - 일관성이 높아진다.
- 팁(Tip)
    - 새 데이터 구조가 문제영역을 간력하게 표현하는 새로운 추상개념으로 격상되면서 코드의 개념적인 그림을 다시 그릴 수 있다.
    - 클래스로 만들면 동작까지도 함께 묶기 좋아진다.
    
## 여러 함수를 클래스로 묶기
- (함수 호출시 인수로 전달되는)공통 데이터를 중심으로 긴밀하게 엮여 작동하는 함수 무리를 발견하면 클래스를 하나로 묶는다.
- 언제 사용하는게 좋은가?
    - 이미 만들어진 함수들을 재구성할 때
    - 새로 만든 클래스와 관련하여 놓친 연산을 찾아서 새 클래스의 메소드를 뽑아낼 때 
- 장점
    - 클라이언트가 객체의 핵심 데이터를 변경할 수 있다.
    - 파생 객체들을 일관되게 관리할 수있다.
- 팁
    - 함수를 한데 묶는 또 다른 방법으로 `여러 함수를 변환함수로 묶기(6.10)`가 있다.
    - 중첩함수 형태로 묶어도 된다.
        - 다만, 중첩함수는 테스트가 까다로울 수 있다.
    - 클래스를 지원하지 않는 언어에서는 `함수를 객체처럼 패턴(Function As Object)`을 이용하기도 한다.
    
## 여러 함수를 변환 함수로 묶기
- 입력받은 데이터를 여러가지 정보로 도출한 데이터를 여러군데에서 사용될때(중복된 도출 로직이 존재)
- 장점
    - 검색과 갱신이 일관된 장소에서 처리된다.
    - 중복 로직을 막을 수 있다.
- 팁
    - 변환할 레코드는 대체로 깊은 복사로 처리해라.
    - `여러 함수를 클래스로 묶기(6.9)`를 적용하여도 동일하다.
        - 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 낫다.(일관성 문제)
    - 네이밍 방법
        - 부가정보만 덧붙이는 경우 변함 함수의 이름을 'enrich'
        - 형태가 변할 때만 'transform'
        
## 단계 쪼개기
- 서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각 모듈을 나누는 방법을 모색한다.
- 동작이 연이은 경우 두 단계로 쪼갠다.
    - 각 단계는 서로 확연히 다른 일을 수행

